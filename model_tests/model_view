#include "filesystemmodel.h"

#include <QDir>
#include <QFileIconProvider>
#include <QDateTime>

#define SEPARATOR QString("/")

// This class represents a row in FileSystemModel
class FileSystemItem
{
public:
  FileSystemItem(const QFileInfo& fileInfo,FileSystemItem* parent = 0)
  {
    mParent = parent;
    mFileInfo = fileInfo;

    if(parent){
      parent->addChild(this);

      // NOTE: absoluteFilePath method of QFileInfo class cause the file system
      // query hence causes slower performance, We are going to keep the
      // absolutepath of an item. Absolute path means the absolute path of parent
      // plus a separator plus filename of this item.
      if(0 == parent->parent()){
        // for drives, there is no filename, so we used canonicalPath
        mAbsFilePath = fileInfo.canonicalPath();
      }
      else{
        mAbsFilePath = parent->absoluteFilePath() + SEPARATOR + fileInfo.fileName();
      }
    }
    else{
      // Path of root item, which is not visible;
      mAbsFilePath = "";
    }
  }

  ~FileSystemItem()
  {
    qDeleteAll(mChildren);
  }


  FileSystemItem* childAt(int position)
  {
    return mChildren.value(position,0);
  }

  int childCount() const
  {
    return mChildren.count();
  }

  // returns the position of this son among his siblings
  int childNumber() const
  {
    if (mParent){
          return mParent->mChildren.indexOf(const_cast<FileSystemItem*>(this));
        }

    return 0;
  }

  FileSystemItem* parent()
  {
    return mParent;
  }

  QString absoluteFilePath()const
  {
    return mAbsFilePath;
  }

  QString fileName()const
  {
    if(mParent){
      // for drives, there is no filename, so we used canonicalPath
      if(0 == mParent->parent()){
        return mFileInfo.canonicalPath();
      }
      else{
        return mFileInfo.fileName();
      }
    }

    return "";
  }

  QFileInfo fileInfo()const
  {
    return mFileInfo;
  }

  void addChild(FileSystemItem *child)
  {
    if(!mChildren.contains(child)){
      mChildren.append(child);
    }
  }

  // This is a recursive method which tries to match a path to a specifiq
  // FileSystemItem item which has the path;
  // Here startIndex is the position of the separator
  FileSystemItem* matchPath(const QStringList& path, int startIndex = 0)
  {
    foreach(FileSystemItem* child, mChildren){
      QString match = path.at(startIndex);

      if(child->fileName() == match){
        if(startIndex + 1 == path.count()){
          return child;
        }
        else{
          return child->matchPath(path,startIndex + 1);
        }
      }
    }

    return 0;
  }

private:
  FileSystemItem* mParent;
  QList<FileSystemItem*> mChildren;
  QFileInfo mFileInfo;
  QString mAbsFilePath;
};

// End of FileSystemItem class

FileSystemModel: This class is the Model itself.

class FileSystemModel : public QAbstractItemModel
{
Q_OBJECT

public:
  enum Column{NAME, SIZE, TYPE, DATE, LASTCOLUMN};
FileSystemModel(QObject* parent)
  : QAbstractItemModel(parent),mIconFactory(new QFileIconProvider())
{
  // Now it is time to fix the headers
  mHeaders << "Name"
           << "Size"
           << "Type"
           << "Date Modified";

  // Create the root item [NOTE: Root item is not visible, but is the parent
  // of all drives]
  mRootItem = new FileSystemItem(QFileInfo(),0);
  mCurrentPath = "";

  QFileInfoList drives = QDir::drives();

  foreach(QFileInfo drive, drives){
    new FileSystemItem(drive,mRootItem);
  }
}

~FileSystemModel()
{
  delete mRootItem;
  delete mIconFactory;
}

QVariant headerData(int section, Qt::Orientation orientation,
                               int role) const
{
  if(orientation == Qt::Horizontal){
    switch(role){
    // in case of DisplayRole, just return the header text
    case Qt::DisplayRole:
      return mHeaders.at(section);
      break;
    // in case of TextAlignmentRole, only SIZE column will be right align,
    // others will be left align
    case Qt::TextAlignmentRole:
      return int(SIZE) == section ? Qt::AlignRight : Qt::AlignLeft;
      break;
    }
  }

  return QVariant();
}

Qt::ItemFlags flags(const QModelIndex &index) const
{
  if (!index.isValid())
      return 0;

  // Our model is read only.
  return Qt::ItemIsEnabled | Qt::ItemIsSelectable;
}

int columnCount(const QModelIndex & /* parent */) const
{
  return LASTCOLUMN; // here it is; 4.
}

int rowCount(const QModelIndex &parent) const
{
  FileSystemItem *parentItem = getItem(parent);
  return parentItem->childCount();
}

QVariant data(const QModelIndex &index, int role) const
{
  // invalid work, invalid return
  if (!index.isValid()){
    return QVariant();
  }

  // in case of TextAlignmentRole, only SIZE column will be right align,
  // others will be left align
  if(int(SIZE) == index.column() && Qt::TextAlignmentRole == role){
    return Qt::AlignRight;
  }

  // At present, I don't want pay attention other than DisplayRole & DecorationRole
  if (role != Qt::DisplayRole && role != Qt::DecorationRole){
      return QVariant();
    }

  FileSystemItem *item = getItem(index);

  if(!item){
    return QVariant();
  }

  // if the role is for decoration & column is zero, we send the item's icon
  if(role == Qt::DecorationRole && index.column() == int(NAME) ){
    return mIconFactory->icon(item->fileInfo());
  }

  QVariant data;
  Column col = Column(index.column());

  switch(col){
  case NAME:
    data = item->fileName();
    break;
  case SIZE:
    if(item->fileInfo().isDir()){
      data = ""; // we don't want to show zero.
    }
    else{
      data = item->fileInfo().size();
    }
    break;
  case TYPE:
    data = mIconFactory->type(item->fileInfo());
    break;
  case DATE:
    data = item->fileInfo().lastModified().toString(Qt::LocalDate);
    break;
  default:
    data = "";
    break;
  }

  return data;
}

QModelIndex index(int row, int column, const QModelIndex &parent) const
{
  // As the NAME column is a tree, we will only create index which parent is NAME column
  if (parent.isValid() && parent.column() != int(NAME))
      return QModelIndex();

  FileSystemItem *parentItem = getItem(parent);

  // if there is a parent index, we want to work
  if(parentItem){
    FileSystemItem *childItem = parentItem->childAt(row);

    if (childItem){
        return createIndex(row, column, childItem);
      }
  }

  return QModelIndex();
}

QModelIndex index(const QString& path, int column) const
{
  if(path.length() > 0){
    FileSystemItem *item = mRootItem->matchPath(path.split(SEPARATOR));

    if(item){
      return createIndex(item->childNumber(),column,item);
    }
  }

  return QModelIndex();
}

QModelIndex parent(const QModelIndex &index) const
{
  // invalid work, invalid return
  if(!index.isValid()){
      return QModelIndex();
    }

  FileSystemItem* childItem = getItem(index);

  // If there is no child, there is no index
  if(!childItem){
      return QModelIndex();
    }

  FileSystemItem *parentItem = childItem->parent();

  // if there is no parent or parent is invisible, there is no index
  if (!parentItem || parentItem == mRootItem){
      return QModelIndex();
    }

  return createIndex(parentItem->childNumber(), NAME, parentItem);
}

bool isDir(const QModelIndex &index)
{
  FileSystemItem *item = static_cast<FileSystemItem*>(index.internalPointer());

  if(item && item != mRootItem){
    return item->fileInfo().isDir();
  }

  return false;
}

// NOTE: absoluteFilePath method of QFileInfo class cause the file system
// query hence causes slower performance, We are going to keep the
// absolutepath of an item. Absolute path means the absolute path of parent
// plus a separator plus filename of this item.
QString absolutePath(const QModelIndex &index)
{
  FileSystemItem *item = static_cast<FileSystemItem*>(index.internalPointer());

  if(item && item != mRootItem){
    return item->absoluteFilePath();
  }

  return "";
}

QString currentPath()const
{
  return mCurrentPath;
}

QModelIndex setCurrentPath(const QString& path)
{
  mCurrentPath = path;

  // find the file system item
  FileSystemItem *item = mRootItem->matchPath(path.split(SEPARATOR));

  // if there is a item and item's child is zero, we are going to find the
  // entries in the directory
  if(item && item != mRootItem && item->childCount() == 0){
    populateItem(item);
  }

  return index(path);
}

private:
void populateItem(FileSystemItem *item)
{
  QDir dir(item->absoluteFilePath());
  QFileInfoList all = dir.entryInfoList(QDir::AllEntries | QDir::NoDotAndDotDot);

  // loop through all the item and construct the childs
  foreach(QFileInfo one, all){
    new FileSystemItem(one,item);
  }
}

FileSystemItem *getItem(const QModelIndex &index) const
{
  // just return the internal pointer we set at creating index if the index is valid
  if(index.isValid()) {
      FileSystemItem *item = static_cast<FileSystemItem*>(index.internalPointer());

      if(item) {
        return item;
      }
  }

  return mRootItem;
}
private:
  FileSystemItem* mRootItem;
  QString mCurrentPath;
  QStringList mHeaders;
  QFileIconProvider* mIconFactory;
};

FileSystemSortProxyModel: Sort/Proxy Model

class FileSystemSortProxyModel  : public QSortFilterProxyModel
{
Q_OBJECT
public:
FileSystemSortProxyModel(QObject *parent) :
    QSortFilterProxyModel(parent)
{
}
protected:
bool lessThan(const QModelIndex &left, const QModelIndex &right) const
{
  FileSystemModel* fsModel = dynamic_cast<FileSystemModel*>(sourceModel());

  // To keep the the folder always on the up, we need to do the followings
  // while the compare indice are folder & file exclusively.
  if(fsModel){
    if((fsModel->isDir(left) && !fsModel->isDir(right))){
      return sortOrder() == Qt::AscendingOrder;
    }
    else if( (!fsModel->isDir(left) && fsModel->isDir(right))){
      return sortOrder() == Qt::DescendingOrder;
    }
  }

  return QSortFilterProxyModel::lessThan(left,right);
}
};


View class
DirBrowser: Now the view class.

class DirBrowser  : public QTableView
{
Q_OBJECT
public: 
DirBrowser(QWidget *parent) :
    QTableView(parent)
{
  grabKeyboard();  

  /* IMPORTANT
     Construct the QFileSystemModel. This is relatively faster
     that QDirModel.

     ****** TODO ******
     However, QFileSystemModel is not fast enough as windows system explorer.
     We have to consider platform specifiq API in this case, like
     FindFirstFile or FindFirstFileEx with looping FindNextFile.
     In this case we have to completely make a View class to show contents on this.
     I have worked with this APIs at past, yet need some R&D's on this.
     In this case, there are challenges like finding the item's icon & item's
     text color.
  */
  //mFSModel = new QFileSystemModel(this);
  mFSModel = new FileSystemModel(this);
  //mFSModel->setRootPath(QDir::currentPath()); // This will populate the filesystem
  mSortModel = new FileSystemSortProxyModel(this);
  mSortModel->setSourceModel(mFSModel);

  this->setShowGrid(false);
  this->verticalHeader()->hide();
  this->setModel(mSortModel);
  this->setSortingEnabled(true);

  /* Now, binds the necessary signals & corresponding slots.
     One thing ro remember is that, we are the setting the signal
     ConnectionType to AutoConnection (default). So if a signal is emitted
     in another thread, yet the slot will run on invoked objects thread.
  */
  // Binds the doubleClicked signal to handleDirItemDoubleClicked slot of this class
  connect(this,SIGNAL(doubleClicked(QModelIndex)),SLOT(handleDirItemDoubleClicked(QModelIndex)));
}

private slots:
void handleDirItemDoubleClicked(const QModelIndex &index)
{
  if(mFSModel->isDir(mSortModel->mapToSource(index))){
    updateCurrentPath(index);
  }
}

protected:
void keyPressEvent(QKeyEvent *e)
{
  // if bakcspace key is pressed, view the dir browser to updates
  // parent folder
  if(e->key() == Qt::Key_Backspace){
    // If parent model-index is valid, up one level; Otherwise
    // back to topmost level
    if(this->rootIndex().parent().isValid()){
      updateCurrentPath(this->rootIndex().parent());
    }
    else{
      this->setRootIndex(mSortModel->mapFromSource(mFSModel->setCurrentPath("")));
    }
  }
}

private:
void updateCurrentPath(const QModelIndex &index)
{
  if(index.isValid()){
    // update the model for current path
    mFSModel->setCurrentPath(mFSModel->absolutePath(mSortModel->mapToSource(index)));
    // update the view as necessarily
    this->setRootIndex(mSortModel->mapFromSource(mFSModel->index(mFSModel->currentPath())));
  }
}
private:
  FileSystemModel* mFSModel;
  FileSystemSortProxyModel* mSortModel;
};
